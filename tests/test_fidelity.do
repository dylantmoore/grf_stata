* test_fidelity.do -- R-vs-Stata numerical fidelity tests
* Compares Stata grf results to R grf reference data in ref/
*
* WORKING DIRECTORY: This file must be run from the project root
* (i.e., the directory containing the ref/ folder and *.ado files).
*   cd /path/to/grf_stata
*   do tests/test_fidelity.do
*
* Reference data is generated by: Rscript tests/generate_reference.R
* (also run from the project root). Both scripts use ref/ relative
* to CWD, so paths are consistent as long as CWD = project root.
*
* Each comparison gracefully skips if reference files are missing,
* allowing the test suite to pass even if R has not been run yet.

clear all
set more off
capture restore

local errors = 0

capture restore

* ============================================================
* 1. Regression OOB predictions (correlation > 0.95)
capture restore

* ============================================================
capture confirm file "ref/regression_input.csv"
if _rc {
    display as text "SKIP: regression predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/regression_input.csv", clear
        grf_regression_forest y x1-x5, gen(pred_stata) ntrees(2000) seed(42)

        * Load R predictions
        preserve
        import delimited using "ref/regression_output.csv", clear
        rename prediction pred_r
        tempfile r_preds
        save `r_preds'
        restore

        merge 1:1 _n using `r_preds', nogenerate
        correlate pred_stata pred_r
        assert r(rho) > 0.95
    }
    if _rc {
        display as error "FAIL: regression predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: regression predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 2. Causal ATE (all) -- z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_input.csv"
if _rc {
    display as text "SKIP: causal ATE all (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/causal_input.csv", clear
        grf_causal_forest y w x1-x5, gen(cate_fid) ntrees(2000) seed(42)
        grf_ate
        local stata_ate = r(ate)
        local stata_se  = r(se)

        * Load R ATE
        preserve
        import delimited using "ref/causal_ate.csv", clear
        local r_ate = estimate[1]
        local r_se  = std_err[1]
        restore

        * z-test: |stata - R| / sqrt(se_stata^2 + se_R^2)
        local z = abs(`stata_ate' - `r_ate') / sqrt(`stata_se'^2 + `r_se'^2)
        assert `z' < 3
    }
    if _rc {
        display as error "FAIL: causal ATE (all)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: causal ATE (all)"
    }
}

capture restore

* ============================================================
* 3. Causal ATE (treated) -- z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_ate_treated.csv"
if _rc {
    display as text "SKIP: causal ATE treated (ref file missing)"
}
else {
    capture noisily {
        * Reuse data from previous test; re-fit if needed
        capture confirm variable cate_fid
        if _rc {
            import delimited using "ref/causal_input.csv", clear
            grf_causal_forest y w x1-x5, gen(cate_fid) ntrees(2000) seed(42)
        }
        grf_ate, targetsample(treated)
        local stata_ate = r(ate)
        local stata_se  = r(se)

        preserve
        import delimited using "ref/causal_ate_treated.csv", clear
        local r_ate = estimate[1]
        local r_se  = std_err[1]
        restore

        local z = abs(`stata_ate' - `r_ate') / sqrt(`stata_se'^2 + `r_se'^2)
        assert `z' < 3
    }
    if _rc {
        display as error "FAIL: causal ATE (treated)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: causal ATE (treated)"
    }
}

capture restore

* ============================================================
* 4. Causal ATE (control) -- z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_ate_control.csv"
if _rc {
    display as text "SKIP: causal ATE control (ref file missing)"
}
else {
    capture noisily {
        capture confirm variable cate_fid
        if _rc {
            import delimited using "ref/causal_input.csv", clear
            grf_causal_forest y w x1-x5, gen(cate_fid) ntrees(2000) seed(42)
        }
        grf_ate, targetsample(control)
        local stata_ate = r(ate)
        local stata_se  = r(se)

        preserve
        import delimited using "ref/causal_ate_control.csv", clear
        local r_ate = estimate[1]
        local r_se  = std_err[1]
        restore

        local z = abs(`stata_ate' - `r_ate') / sqrt(`stata_se'^2 + `r_se'^2)
        assert `z' < 3
    }
    if _rc {
        display as error "FAIL: causal ATE (control)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: causal ATE (control)"
    }
}

capture restore

* ============================================================
* 5. Causal ATE (overlap) -- z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_ate_overlap.csv"
if _rc {
    display as text "SKIP: causal ATE overlap (ref file missing)"
}
else {
    capture noisily {
        capture confirm variable cate_fid
        if _rc {
            import delimited using "ref/causal_input.csv", clear
            grf_causal_forest y w x1-x5, gen(cate_fid) ntrees(2000) seed(42)
        }
        grf_ate, targetsample(overlap)
        local stata_ate = r(ate)
        local stata_se  = r(se)

        preserve
        import delimited using "ref/causal_ate_overlap.csv", clear
        local r_ate = estimate[1]
        local r_se  = std_err[1]
        restore

        local z = abs(`stata_ate' - `r_ate') / sqrt(`stata_se'^2 + `r_se'^2)
        assert `z' < 3
    }
    if _rc {
        display as error "FAIL: causal ATE (overlap)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: causal ATE (overlap)"
    }
}

capture restore

* ============================================================
* 6. Causal BLP coefficients -- per-coefficient z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_blp.csv"
if _rc {
    display as text "SKIP: causal BLP coefficients (ref file missing)"
}
else {
    capture noisily {
        * Re-fit causal forest (BLP replaces e())
        import delimited using "ref/causal_input.csv", clear
        grf_causal_forest y w x1-x5, gen(cate_blp) ntrees(2000) seed(42)
        grf_best_linear_projection x1-x5

        * Save Stata coefficients (intercept + x1..x5)
        matrix b_stata = e(b)
        matrix V_stata = e(V)

        * Load R BLP results
        preserve
        import delimited using "ref/causal_blp.csv", clear
        * R file has: variable, estimate, std.error, t.value, p.value
        * Row 1 = intercept, rows 2-6 = x1..x5
        * Stata column order: x1 x2 x3 x4 x5 _cons
        local blp_ok 1
        forvalues j = 1/5 {
            local r_est = estimate[`j' + 1]
            local r_se  = std_error[`j' + 1]
            local s_est = b_stata[1, `j']
            local s_se  = sqrt(V_stata[`j', `j'])
            local z = abs(`s_est' - `r_est') / sqrt(`s_se'^2 + `r_se'^2)
            if `z' >= 3 {
                local blp_ok 0
            }
        }
        * Also check intercept (last column in Stata = _cons, first row in R)
        local ncols = colsof(b_stata)
        local r_est = estimate[1]
        local r_se  = std_error[1]
        local s_est = b_stata[1, `ncols']
        local s_se  = sqrt(V_stata[`ncols', `ncols'])
        local z = abs(`s_est' - `r_est') / sqrt(`s_se'^2 + `r_se'^2)
        if `z' >= 3 {
            local blp_ok 0
        }
        restore

        assert `blp_ok' == 1
    }
    if _rc {
        display as error "FAIL: causal BLP coefficients"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: causal BLP coefficients"
    }
}

capture restore

* ============================================================
* 7. Variable importance rank correlation (Spearman > 0.70)
capture restore

* ============================================================
capture confirm file "ref/causal_variable_importance.csv"
if _rc {
    display as text "SKIP: variable importance rank correlation (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/causal_input.csv", clear
        grf_variable_importance y x1-x5, ntrees(2000) seed(42)
        matrix vi_stata = r(importance)

        * Load R variable importance
        preserve
        import delimited using "ref/causal_variable_importance.csv", clear

        * Create a dataset with both R and Stata importance for Spearman rank
        gen vi_stata = .
        forvalues j = 1/5 {
            replace vi_stata = vi_stata[1, `j'] if _n == `j'
        }

        * Compute Spearman rank correlation manually
        * Rank R importance
        egen rank_r = rank(importance)
        * Rank Stata importance
        egen rank_s = rank(vi_stata)
        correlate rank_r rank_s
        local spearman = r(rho)
        restore

        assert `spearman' > 0.70
    }
    if _rc {
        display as error "FAIL: variable importance rank correlation"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: variable importance rank correlation"
    }
}

capture restore

* ============================================================
* 8. DR scores correlation (> 0.90)
capture restore

* ============================================================
capture confirm file "ref/causal_scores.csv"
if _rc {
    display as text "SKIP: DR scores correlation (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/causal_input.csv", clear
        grf_causal_forest y w x1-x5, gen(cate_sc) ntrees(2000) seed(42)
        grf_get_scores, gen(scores_stata)

        * Load R DR scores
        preserve
        import delimited using "ref/causal_scores.csv", clear
        rename score score_r
        tempfile r_scores
        save `r_scores'
        restore

        merge 1:1 _n using `r_scores', nogenerate
        correlate scores_stata score_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: DR scores correlation"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: DR scores correlation"
    }
}

capture restore

* ============================================================
* 9. Quantile forest predictions (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/quantile_input.csv"
if _rc {
    display as text "SKIP: quantile predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/quantile_input.csv", clear
        grf_quantile_forest y x1-x5, gen(qpred) quantiles(.1 .25 .5 .75 .9) ///
            ntrees(2000) seed(42)

        * Load R quantile predictions (median = q0.5)
        preserve
        import delimited using "ref/quantile_output.csv", clear
        rename q0_5 pred_r
        tempfile r_qpreds
        save `r_qpreds'
        restore

        merge 1:1 _n using `r_qpreds', nogenerate
        correlate qpred_q50 pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: quantile predictions (correlation with R median)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: quantile predictions (correlation with R median)"
    }
}

capture restore

* ============================================================
* 10. Probability forest class probabilities (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/probability_input.csv"
if _rc {
    display as text "SKIP: probability predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/probability_input.csv", clear
        grf_probability_forest y x1-x5, gen(pprob) nclasses(3) ///
            ntrees(2000) seed(42)

        * Load R class probabilities (class 0)
        preserve
        import delimited using "ref/probability_output.csv", clear
        rename class0 prob_r
        tempfile r_pprobs
        save `r_pprobs'
        restore

        merge 1:1 _n using `r_pprobs', nogenerate
        correlate pprob_c0 prob_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: probability predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: probability predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 11. Instrumental forest LATE (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/instrumental_input.csv"
if _rc {
    display as text "SKIP: instrumental predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/instrumental_input.csv", clear
        grf_instrumental_forest y w z x1-x5, gen(late_stata) ///
            ntrees(2000) seed(42)

        * Load R LATE predictions
        preserve
        import delimited using "ref/instrumental_output.csv", clear
        rename late pred_r
        tempfile r_late
        save `r_late'
        restore

        merge 1:1 _n using `r_late', nogenerate
        correlate late_stata pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: instrumental LATE (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: instrumental LATE (correlation with R)"
    }
}

capture restore

* ============================================================
* 12. Survival forest predictions (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/survival_input.csv"
if _rc {
    display as text "SKIP: survival predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/survival_input.csv", clear
        grf_survival_forest time status x1-x5, gen(surv_stata) ///
            ntrees(2000) seed(42)

        * Load R survival predictions (first failure time column)
        preserve
        import delimited using "ref/survival_output.csv", clear
        rename t1 pred_r
        tempfile r_surv
        save `r_surv'
        restore

        merge 1:1 _n using `r_surv', nogenerate
        correlate surv_stata_s1 pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: survival predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: survival predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 13. Expected survival E[T|X] (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/survival_expected.csv"
if _rc {
    display as text "SKIP: expected survival (ref file missing)"
}
else {
    capture noisily {
        * Always re-fit survival forest with noutput(400) so all failure times
        * are saved as prediction columns.  The default noutput(20) covers only
        * a small fraction of the time range, causing underestimation of E[T|X].
        * R's reference integrates over ALL unique failure times (~329 for this
        * dataset), so we need at least that many columns here.
        import delimited using "ref/survival_input.csv", clear
        * Drop any existing surv_stata_* columns from a prior fit
        capture drop surv_stata_s*
        grf_survival_forest time status x1-x5, gen(surv_stata) ///
            ntrees(2000) seed(42) noutput(400)
        grf_expected_survival, gen(et_stata)

        * Load R expected survival
        preserve
        import delimited using "ref/survival_expected.csv", clear
        rename expected_time et_r
        tempfile r_et
        save `r_et'
        restore

        merge 1:1 _n using `r_et', nogenerate
        correlate et_stata et_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: expected survival E[T|X] (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: expected survival E[T|X] (correlation with R)"
    }
}

capture restore

* ============================================================
* 14. Causal APE -- z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_ape.csv"
if _rc {
    display as text "SKIP: causal APE (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/causal_ape_input.csv", clear
        grf_causal_forest y w x1-x5, gen(cate_ape) ntrees(2000) seed(42)
        grf_ate
        local stata_ape = r(ate)
        local stata_se  = r(se)

        preserve
        import delimited using "ref/causal_ape.csv", clear
        local r_ape = estimate[1]
        local r_se  = std_err[1]
        restore

        local z = abs(`stata_ape' - `r_ape') / sqrt(`stata_se'^2 + `r_se'^2)
        assert `z' < 3
    }
    if _rc {
        display as error "FAIL: causal APE"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: causal APE"
    }
}

capture restore

* ============================================================
* 15. Causal test calibration -- per-coefficient z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_test_calibration.csv"
if _rc {
    display as text "SKIP: causal test calibration (ref file missing)"
}
else {
    capture noisily {
        * Re-fit causal forest on standard data
        import delimited using "ref/causal_input.csv", clear
        grf_causal_forest y w x1-x5, gen(cate_tc) ntrees(2000) seed(42)
        grf_test_calibration

        matrix b_tc = e(b)
        matrix V_tc = e(V)

        preserve
        import delimited using "ref/causal_test_calibration.csv", clear
        local tc_ok 1
        local ncols = colsof(b_tc)
        forvalues j = 1/`ncols' {
            local s_est = b_tc[1, `j']
            local s_se  = sqrt(V_tc[`j', `j'])
            local r_est = estimate[`j']
            local r_se  = std_error[`j']
            local z = abs(`s_est' - `r_est') / sqrt(`s_se'^2 + `r_se'^2)
            if `z' >= 3 {
                local tc_ok 0
            }
        }
        restore
        assert `tc_ok' == 1
    }
    if _rc {
        display as error "FAIL: causal test calibration"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: causal test calibration"
    }
}

capture restore

* ============================================================
* 16. BLP HC0 standard errors -- per-coefficient z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_blp_hc0.csv"
if _rc {
    display as text "SKIP: BLP HC0 (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/causal_input.csv", clear
        grf_causal_forest y w x1-x5, gen(cate_hc0) ntrees(2000) seed(42)
        grf_best_linear_projection x1-x5, vcov(hc0)

        matrix b_hc0 = e(b)
        matrix V_hc0 = e(V)

        preserve
        import delimited using "ref/causal_blp_hc0.csv", clear
        local hc0_ok 1
        * Check x1..x5 (rows 2-6 in R, cols 1-5 in Stata)
        forvalues j = 1/5 {
            local r_est = estimate[`j' + 1]
            local r_se  = std_error[`j' + 1]
            local s_est = b_hc0[1, `j']
            local s_se  = sqrt(V_hc0[`j', `j'])
            local z = abs(`s_est' - `r_est') / sqrt(`s_se'^2 + `r_se'^2)
            if `z' >= 3 {
                local hc0_ok 0
            }
        }
        * Intercept (row 1 in R, last col in Stata)
        local ncols = colsof(b_hc0)
        local r_est = estimate[1]
        local r_se  = std_error[1]
        local s_est = b_hc0[1, `ncols']
        local s_se  = sqrt(V_hc0[`ncols', `ncols'])
        local z = abs(`s_est' - `r_est') / sqrt(`s_se'^2 + `r_se'^2)
        if `z' >= 3 {
            local hc0_ok 0
        }
        restore
        assert `hc0_ok' == 1
    }
    if _rc {
        display as error "FAIL: BLP HC0 standard errors"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: BLP HC0 standard errors"
    }
}

capture restore

* ============================================================
* 17. BLP HC3 standard errors -- per-coefficient z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_blp_hc3.csv"
if _rc {
    display as text "SKIP: BLP HC3 (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/causal_input.csv", clear
        grf_causal_forest y w x1-x5, gen(cate_hc3) ntrees(2000) seed(42)
        grf_best_linear_projection x1-x5, vcov(hc3)

        matrix b_hc3 = e(b)
        matrix V_hc3 = e(V)

        preserve
        import delimited using "ref/causal_blp_hc3.csv", clear
        local hc3_ok 1
        forvalues j = 1/5 {
            local r_est = estimate[`j' + 1]
            local r_se  = std_error[`j' + 1]
            local s_est = b_hc3[1, `j']
            local s_se  = sqrt(V_hc3[`j', `j'])
            local z = abs(`s_est' - `r_est') / sqrt(`s_se'^2 + `r_se'^2)
            if `z' >= 3 {
                local hc3_ok 0
            }
        }
        local ncols = colsof(b_hc3)
        local r_est = estimate[1]
        local r_se  = std_error[1]
        local s_est = b_hc3[1, `ncols']
        local s_se  = sqrt(V_hc3[`ncols', `ncols'])
        local z = abs(`s_est' - `r_est') / sqrt(`s_se'^2 + `r_se'^2)
        if `z' >= 3 {
            local hc3_ok 0
        }
        restore
        assert `hc3_ok' == 1
    }
    if _rc {
        display as error "FAIL: BLP HC3 standard errors"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: BLP HC3 standard errors"
    }
}

capture restore

* ============================================================
* 18. RATE AUTOC -- z-test < 3
capture restore

* ============================================================
capture confirm file "ref/causal_rate_autoc.csv"
if _rc {
    display as text "SKIP: RATE AUTOC (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/causal_input.csv", clear
        grf_causal_forest y w x1-x5, gen(cate_rate) ntrees(2000) seed(42)
        grf_rate cate_rate
        local stata_est = r(estimate)
        local stata_se  = r(std_err)

        preserve
        import delimited using "ref/causal_rate_autoc.csv", clear
        local r_est = estimate[1]
        local r_se  = std_err[1]
        restore

        local z = abs(`stata_est' - `r_est') / sqrt(`stata_se'^2 + `r_se'^2)
        assert `z' < 3
    }
    if _rc {
        display as error "FAIL: RATE AUTOC"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: RATE AUTOC"
    }
}

capture restore

* ============================================================
* 19. Local linear regression forest predictions (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/ll_regression_input.csv"
if _rc {
    display as text "SKIP: LL regression predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/ll_regression_input.csv", clear
        grf_ll_regression_forest y x1-x5, gen(llpred_stata) ///
            ntrees(2000) seed(42)

        preserve
        import delimited using "ref/ll_regression_output.csv", clear
        rename prediction pred_r
        tempfile r_llpreds
        save `r_llpreds'
        restore

        merge 1:1 _n using `r_llpreds', nogenerate
        correlate llpred_stata pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: LL regression predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: LL regression predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 20. LM forest coefficient predictions (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/lm_forest_input.csv"
if _rc {
    display as text "SKIP: LM forest predictions (ref file missing)"
}
else {
    capture noisily {
        * Input has columns: x1-x5 (covariates), w (treatment), y (outcome).
        * W is separate from X so nuisance E[W|X] is comparable between R and Stata.
        import delimited using "ref/lm_forest_input.csv", clear
        grf_lm_forest y w, gen(lmpred_stata) xvars(x1 x2 x3 x4 x5) ///
            ntrees(2000) seed(42)

        * Compare coefficient column for w
        preserve
        import delimited using "ref/lm_forest_output.csv", clear
        rename coef1 pred_r
        tempfile r_lmpreds
        save `r_lmpreds'
        restore

        merge 1:1 _n using `r_lmpreds', nogenerate
        correlate lmpred_stata_1 pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: LM forest predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: LM forest predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 21. Multi-arm causal forest contrasts (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/multi_arm_input.csv"
if _rc {
    display as text "SKIP: multi-arm predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/multi_arm_input.csv", clear

        * R encodes W as a 3-level factor (control=0, treat1=1, treat2=2).
        * multi_arm_causal_forest internally uses K-1=2 binary indicators.
        * Replicate this: create binary indicators for each non-control arm.
        gen byte w1 = (w == 1)
        gen byte w2 = (w == 2)

        grf_multi_arm_causal_forest y w1 w2 x1-x5, gen(mapred_stata) ///
            ntreat(2) ntrees(2000) seed(42)

        * Compare first contrast column (treat1 vs control)
        preserve
        import delimited using "ref/multi_arm_output.csv", clear
        rename contrast1 pred_r
        tempfile r_mapreds
        save `r_mapreds'
        restore

        merge 1:1 _n using `r_mapreds', nogenerate
        correlate mapred_stata_t1 pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: multi-arm predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: multi-arm predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 22. Multi-regression forest predictions (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/multi_regression_input.csv"
if _rc {
    display as text "SKIP: multi-regression predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/multi_regression_input.csv", clear
        grf_multi_regression_forest y1 y2 x1-x5, gen(mrpred_stata) ndep(2) ///
            ntrees(2000) seed(42)

        * Compare first outcome predictions
        preserve
        import delimited using "ref/multi_regression_output.csv", clear
        rename pred_y1 pred_r
        tempfile r_mrpreds
        save `r_mrpreds'
        restore

        merge 1:1 _n using `r_mrpreds', nogenerate
        correlate mrpred_stata_y1 pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: multi-regression predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: multi-regression predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 23. Causal survival forest CATE (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/causal_survival_input.csv"
if _rc {
    display as text "SKIP: causal survival predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/causal_survival_input.csv", clear

        * Read the horizon used in R
        preserve
        import delimited using "ref/causal_survival_horizon.csv", clear
        local cs_horizon = horizon[1]
        restore

        grf_causal_survival_forest time status w x1-x5, gen(cspred_stata) ///
            ntrees(2000) seed(42) minnodesize(15) horizon(`cs_horizon')

        preserve
        import delimited using "ref/causal_survival_output.csv", clear
        rename cate pred_r
        tempfile r_cspreds
        save `r_cspreds'
        restore

        merge 1:1 _n using `r_cspreds', nogenerate
        correlate cspred_stata pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: causal survival predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: causal survival predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 24. Boosted regression forest predictions (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/boosted_regression_input.csv"
if _rc {
    display as text "SKIP: boosted regression predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/boosted_regression_input.csv", clear
        grf_boosted_regression_forest y x1-x5, gen(brpred_stata) ///
            ntrees(2000) seed(42)

        preserve
        import delimited using "ref/boosted_regression_output.csv", clear
        rename prediction pred_r
        tempfile r_brpreds
        save `r_brpreds'
        restore

        merge 1:1 _n using `r_brpreds', nogenerate
        correlate brpred_stata pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: boosted regression predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: boosted regression predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 25. Causal CATE predictions (correlation > 0.90)
capture restore

* ============================================================
capture confirm file "ref/causal_output.csv"
if _rc {
    display as text "SKIP: causal CATE predictions (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/causal_input.csv", clear
        grf_causal_forest y w x1-x5, gen(cate_corr) ntrees(2000) seed(42)

        preserve
        import delimited using "ref/causal_output.csv", clear
        rename cate pred_r
        tempfile r_cate
        save `r_cate'
        restore

        merge 1:1 _n using `r_cate', nogenerate
        correlate cate_corr pred_r
        assert r(rho) > 0.90
    }
    if _rc {
        display as error "FAIL: causal CATE predictions (correlation with R)"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: causal CATE predictions (correlation with R)"
    }
}

capture restore

* ============================================================
* 26. Regression variable importance rank correlation (Spearman > 0.70)
capture restore

* ============================================================
capture confirm file "ref/regression_variable_importance.csv"
if _rc {
    display as text "SKIP: regression variable importance (ref file missing)"
}
else {
    capture noisily {
        import delimited using "ref/regression_input.csv", clear
        grf_variable_importance y x1-x5, ntrees(2000) seed(42)
        matrix vi_stata = r(importance)

        preserve
        import delimited using "ref/regression_variable_importance.csv", clear

        gen vi_stata = .
        forvalues j = 1/5 {
            replace vi_stata = vi_stata[1, `j'] if _n == `j'
        }

        egen rank_r = rank(importance)
        egen rank_s = rank(vi_stata)
        correlate rank_r rank_s
        local spearman = r(rho)
        restore

        assert `spearman' > 0.70
    }
    if _rc {
        display as error "FAIL: regression variable importance rank correlation"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: regression variable importance rank correlation"
    }
}

capture restore

* ============================================================
* 27. Survival failure times metadata (count match)
capture restore

* ============================================================
capture confirm file "ref/survival_failure_times.csv"
if _rc {
    display as text "SKIP: survival failure times (ref file missing)"
}
else {
    capture noisily {
        * Verify the failure times file is readable and has expected structure
        import delimited using "ref/survival_failure_times.csv", clear
        assert _N > 0
        confirm variable failure_time
        * Failure times should be positive and sorted
        assert failure_time > 0
        sort failure_time
        gen sorted_ok = (failure_time >= failure_time[_n-1]) if _n > 1
        assert sorted_ok == 1 if _n > 1
    }
    if _rc {
        display as error "FAIL: survival failure times metadata"
        local errors = `errors' + 1
    }
    else {
        display as result "PASS: survival failure times metadata"
    }
}

* ============================================================
* Summary
capture restore

* ============================================================
display ""
if `errors' > 0 {
    display as error "FAILED: `errors' fidelity test(s) did not pass"
    exit 1
}
else {
    display as result "ALL FIDELITY TESTS PASSED"
}
